/*
  spike.c
  Copyright Scott Ellis, 2010
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  spike v0.1 loads and registers a spi driver for a device at the bus/
  cable select specified by the constants SPI_BUS.SPI_BUS_CS1
*/

#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/mutex.h>
#include <linux/slab.h>
#include <linux/cdev.h>
#include <linux/spi/spi.h>
#include <linux/string.h>
#include <asm/uaccess.h>

#define USER_BUFF_SIZE 128

#define SPI_BUS 0
#define SPI_BUS_CS 0
#define SPI_BUS_SPEED 1000


const char this_driver_name[] = "spidev"; // Should be slot car...


struct spike_dev {
  struct semaphore spi_sem;
  struct semaphore fop_sem;
  dev_t devt;
  struct cdev cdev;
  struct class *class;
  struct spi_device *spi_device;
  char *user_buff;
  char *length;
  size_t len;
};

static struct spike_dev spike_dev;

static ssize_t spike_write(struct file *filp, const char *buff, size_t len, loff_t *off)
{
  if(spike_dev.spi_device == NULL) {
      printk("spike_dev is null\n");
      return 0;
  }
  printk("spike write\n");
  char temp[USER_BUFF_SIZE];

  unsigned long hej;

  printk("spike write: len: %d\r\n",len);
  hej = copy_from_user(temp,buff,len);
  if(len>USER_BUFF_SIZE)
    temp[99]='\0';
  else
    temp[len] = '\0';
  printk("spike write: copy from user ret %lu\r\n",hej);

  //  spi_write(mydev,temp,len);
  printk("spike write: %s\r\n",temp);

  
  int i;
  for (i = 0; i <= len; i++) {
    size_t res = spi_w8r8(spike_dev.spi_device, temp[i]);
    spike_dev.user_buff[i] = res;
    printk("'%c' '%c' %x\n", temp[i], res, res);
  }
  spike_dev.len = len;

  /*
  char test[100];
  spi_write(spike_dev.spi_device, temp, len);
  spi_read(spike_dev.spi_device, test, len);
  test[99]='\0';
  
  printk("spike write: read %s\r\n",test);
  */
  
  
  printk("spike write: done\n");
}

static ssize_t spike_read(struct file *filp, char __user *buff, size_t count,
			  loff_t *offp)
{
  printk("spike read\n");
  size_t len;
  ssize_t status = 0;

  if (!buff)
    return -EFAULT;

  if (*offp > 0)
    return 0;

  if (down_interruptible(&spike_dev.fop_sem))
    return -ERESTARTSYS;

  if (!spike_dev.spi_device)
    strcpy(spike_dev.user_buff, "spi_device is NULL\n");
  else if (!spike_dev.spi_device->master)
    strcpy(spike_dev.user_buff, "spi_device->master is NULL\n");
  else {
    /*
    sprintf(spike_dev.user_buff, "%s ready on SPI%d.%d\n",
	    this_driver_name,
	    spike_dev.spi_device->master->bus_num,
	    spike_dev.spi_device->chip_select);

    printk(spike_dev.user_buff, "%s ready on SPI%d.%d\n",
	   this_driver_name,
	   spike_dev.spi_device->master->bus_num,
	   spike_dev.spi_device->chip_select);
    */
  }



  len = spike_dev.len;

  printk("spike_dev.len = %d", spike_dev.len);
  len = 4;
 
  if (len < count)
    count = len;

  if (copy_to_user(buff, spike_dev.user_buff, count)) {
    printk(KERN_ALERT "spike_read(): copy_to_user() failed\n");
    status = -EFAULT;
  } else {
    *offp += count;
    status = count;
  }

  up(&spike_dev.fop_sem);

  printk("spike read done\n");
  return status;	
}

static int spike_open(struct inode *inode, struct file *filp)
{	
  printk("spike open\n");
  int status = 0;

  if (down_interruptible(&spike_dev.fop_sem))
    return -ERESTARTSYS;

  if (!spike_dev.user_buff) {
    spike_dev.user_buff = kmalloc(USER_BUFF_SIZE, GFP_KERNEL);
    if (!spike_dev.user_buff)
      status = -ENOMEM;
  }	

  up(&spike_dev.fop_sem);

  return status;
}

static int spike_probe(struct spi_device *spi_device)
{
  printk("spike probe\n");
  if (down_interruptible(&spike_dev.spi_sem))
    return -EBUSY;

  spike_dev.spi_device = spi_device;

  up(&spike_dev.spi_sem);

  printk("spike probe done\n");
  return 0;
}

static int spike_remove(struct spi_device *spi_device)
{
  if (down_interruptible(&spike_dev.spi_sem))
    return -EBUSY;

  spike_dev.spi_device = NULL;

  up(&spike_dev.spi_sem);

  return 0;
}

static int __init add_spike_device_to_bus(void)
{
  printk("spike add_spike_device_to_bus\n");
  struct spi_master *spi_master;
  struct spi_device *spi_device;
  struct device *pdev;
  char buff[64];
  int status = 0;

  spi_master = spi_busnum_to_master(SPI_BUS);

  if (!spi_master) {
    printk(KERN_ALERT "spi_busnum_to_master(%d) returned NULL\n",
	   SPI_BUS);
    printk(KERN_ALERT "Missing modprobe omap2_mcspi?\n");
    return -1;
  }

  /*
  struct spi_board_info fpga_spi_info = {
    
  }

  spi_device = spi_new_device(spi_master, &fpga_spi_info);
  */
  spi_device = spi_alloc_device(spi_master);
  if (!spi_device) {
    put_device(&spi_master->dev);
    printk(KERN_ALERT "spi_alloc_device() failed\n");
    return -1;
  }

  spi_device->chip_select = SPI_BUS_CS;

  /* Check whether this SPI bus.cs is already claimed */
  snprintf(buff, sizeof(buff), "%s.%u",
	   dev_name(&spi_device->master->dev),
	   spi_device->chip_select);

  pdev = bus_find_device_by_name(spi_device->dev.bus, NULL, buff);
  if (pdev) {
    /* We are not going to use this spi_device, so free it */
    spi_dev_put(spi_device);

    /*
     * There is already a device configured for this bus.cs
     * It is okay if it us, otherwise complain and fail.
     */
    if (pdev->driver && pdev->driver->name &&
	strcmp(this_driver_name, pdev->driver->name)) {
      printk(KERN_ALERT
	     "Driver [%s] already registered for %s\n",
	     pdev->driver->name, buff);
      status = -1;
    }
  } else {
    spi_device->max_speed_hz = SPI_BUS_SPEED;
    spi_device->mode = SPI_MODE_0;
    spi_device->bits_per_word = 8;
    spi_device->irq = -1;
    spi_device->controller_state = NULL;
    spi_device->controller_data = NULL;
    strlcpy(spi_device->modalias, this_driver_name, SPI_NAME_SIZE);

    status = spi_add_device(spi_device);	
    if (status < 0) {	
      spi_dev_put(spi_device);
      printk(KERN_ALERT "spi_add_device() failed: %d\n",
	     status);	
    }	
  }

  put_device(&spi_master->dev);

  return status;
}

static struct spi_driver spike_driver = {
  .driver = {
    .name =	this_driver_name,
    .owner = THIS_MODULE,
  },
  .probe = spike_probe,
  .remove = __devexit_p(spike_remove),	
};

static int __init spike_init_spi(void)
{
  printk("spike init spi\n");
  int error;

  error = spi_register_driver(&spike_driver);
  if (error < 0) {
    printk(KERN_ALERT "spi_register_driver() failed %d\n", error);
    return error;
  }

  error = add_spike_device_to_bus();
  if (error < 0) {
    printk(KERN_ALERT "add_spike_to_bus() failed\n");
    spi_unregister_driver(&spike_driver);
    return error;
  }

  return 0;
}

static const struct file_operations spike_fops = {
  .owner =	THIS_MODULE,
  .read = spike_read,
  .write = spike_write,
  .open =	spike_open,	
};

static int __init spike_init_cdev(void)
{
  printk("spike init cdev\n");
  int error;

  spike_dev.devt = MKDEV(0, 0);

  error = alloc_chrdev_region(&spike_dev.devt, 0, 1, this_driver_name);
  if (error < 0) {
    printk(KERN_ALERT "alloc_chrdev_region() failed: %d \n",
	   error);
    return -1;
  }

  cdev_init(&spike_dev.cdev, &spike_fops);
  spike_dev.cdev.owner = THIS_MODULE;

  error = cdev_add(&spike_dev.cdev, spike_dev.devt, 1);
  if (error) {
    printk(KERN_ALERT "cdev_add() failed: %d\n", error);
    unregister_chrdev_region(spike_dev.devt, 1);
    return -1;
  }	

  return 0;
}

static int __init spike_init_class(void)
{
  printk("spike init class\n");
  spike_dev.class = class_create(THIS_MODULE, this_driver_name);

  if (!spike_dev.class) {
    printk(KERN_ALERT "class_create() failed\n");
    return -1;
  }

  if (!device_create(spike_dev.class, NULL, spike_dev.devt, NULL,
		     this_driver_name)) {
    printk(KERN_ALERT "device_create(..., %s) failed\n",
	   this_driver_name);
    class_destroy(spike_dev.class);
    return -1;
  }

  return 0;
}

static int __init spike_init(void)
{
  printk("spike init\n");
  memset(&spike_dev, 0, sizeof(spike_dev));

  sema_init(&spike_dev.spi_sem, 1);
  sema_init(&spike_dev.fop_sem, 1);

  if (spike_init_cdev() < 0)
    goto fail_1;

  if (spike_init_class() < 0)
    goto fail_2;

  if (spike_init_spi() < 0)
    goto fail_3;

  return 0;

 fail_3:
  device_destroy(spike_dev.class, spike_dev.devt);
  class_destroy(spike_dev.class);

 fail_2:
  cdev_del(&spike_dev.cdev);
  unregister_chrdev_region(spike_dev.devt, 1);

 fail_1:
  return -1;
}
module_init(spike_init);

static void __exit spike_exit(void)
{
  printk("spike exit\n");
  spi_unregister_device(spike_dev.spi_device);
  spi_unregister_driver(&spike_driver);

  device_destroy(spike_dev.class, spike_dev.devt);
  class_destroy(spike_dev.class);

  cdev_del(&spike_dev.cdev);
  unregister_chrdev_region(spike_dev.devt, 1);



  if (spike_dev.user_buff)
    kfree(spike_dev.user_buff);
}
module_exit(spike_exit);


MODULE_AUTHOR("Scott Ellis");
MODULE_DESCRIPTION("spike module - an example SPI driver");
MODULE_LICENSE("GPL");
MODULE_VERSION("0.1");
